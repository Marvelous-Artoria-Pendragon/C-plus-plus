/*二叉链表树*/
#ifndef BINARYTREE_H
#define BINARYTREE_H
#include <iostream>
#include <math.h>
#include "Stack.h"
#include "Queue.h"
#include "LinkedList.h"
using namespace std;

template <class T>
struct BinTreeNode                                   //二叉树的链表结点
{
    T data;                                          //数据域
    BinTreeNode<T> *leftChild, *rightChild;          //左子女，右子女链域
    BinTreeNode(): leftChild(NULL), rightChild(NULL){};
    BinTreeNode(T x, BinTreeNode<T> *l = NULL, BinTreeNode<T> *r = NULL)
        : data(x), leftChild(l), rightChild(r){};
};

template <class T>
struct LinearBinTreeNode                            //二叉树的静态链表结点
{
    T data;                                                                     //数据域
    int parent, leftChild, rightChild;                                          //父结点、左子女、右子女
    LinearBinTreeNode() {parent = leftChild = rightChild = -1;}
    LinearBinTreeNode(T x) {data = x; parent = leftChild = rightChild = -1;}
};


template <class T>
class BinaryTree
{
    protected:
        BinTreeNode<T> *root;                                                                   //二叉树的根指针
        T RefValue;                                                                             //数据输入停止的标志
        bool insert(BinTreeNode<T> *&subTree, const T &x);                                      //插入
        void destroy(BinTreeNode<T> *&subTree);                                                 //删除
        //bool Find(BinTreeNode<T> *subTree, const T &x) const;                                   //查找
        BinTreeNode<T> *copy(BinTreeNode<T> *orignode) const;                                   //复制
        int Height(BinTreeNode<T> *subTree) const;                                              //返回数的高度
        int Size(BinTreeNode<T> *subTree) const;                                                //返回结点数
        BinTreeNode<T> *Parent(BinTreeNode<T> *subTree, BinTreeNode<T> *current) const;         //返回父节点
        BinTreeNode<T> *find(BinTreeNode<T> *subTree, const T &x) const;                        //搜寻x，函数返回该结点地址
        void traverse(BinTreeNode<T> *subTree, ostream &out) const;                             //前序遍历输出
        void preOrder(BinTreeNode<T> *subTree, void (*visit)(BinTreeNode<T> *current));         //前序遍历
        void inOrder(BinTreeNode<T> *subTree, void (*visit)(BinTreeNode<T> *current));          //中序遍历
        void postOrder(BinTreeNode<T> *subTree, void (*visit)(BinTreeNode<T> *current));        //中序遍历
        template<class Y>
        friend istream &operator >> (istream &in, BinaryTree<Y> &Tree);                         //重载输入流
        void CreateBinTree(istream &in, BinTreeNode<T> *&subTree);                              //前序遍历递归建树
        void CreateBinTreeByList(istream &in, BinTreeNode<T> *&subTree);                        //根据输入广义表建树

        template<class Y>
        friend ostream &operator << (ostream &out, BinaryTree<Y> &Tree);                        //重载输出流
    public:
        BinaryTree(): root(NULL){};                                                             //构造函数
        BinaryTree(T value): RefValue(value), root(NULL){};                                     //设定停止输入标志的构造函数
        BinaryTree(BinaryTree<T> &s) {root = copy(s.root);}                                     //拷贝构造函数
        ~BinaryTree() {destroy(root);}                                                          //析构函数
        bool isEmpty() const {return (root == NULL ? true : false);}                            //判断二叉树空否
        BinTreeNode<T> *Parent(BinTreeNode<T> *current)                                         //返回父节点
            {return (root == NULL || root == current) ? NULL : Parent(root, current);}
        BinTreeNode<T> *LeftChild(BinTreeNode<T> *current)                                      //返回左子女
            {return (current != NULL) ? current->Child[0] : NULL;}
        BinTreeNode<T> *RightChild(BinTreeNode<T> *current)                                     //返回右子女
            {return (current != NULL) ? current->Child[1] : NULL;}
        int Height() const {return Height(root);}                                               //返回树高度
        int Size() const {return Size(root);}                                                   //返回结点数
        BinTreeNode<T> *getRoot() const{return root;}                                           //返回根结点
        void preOrder(void (*visit)(BinTreeNode<T> *current)) {preOrder(root, visit);}          //前序遍历
        void inOrder(void (*visit)(BinTreeNode<T> *current)) {inOrder(root, visit);}            //中序遍历
        void postOrder(void (*visit)(BinTreeNode<T> *current)) {postOrder(root, visit);}        //后序遍历
        void leverOrder(void (*visit)(BinTreeNode<T> *current));                                //层次遍历
        //int insert(const T &item);                                                              //插入新元素
        //根据值找到该结点，并通过引用返回存储所有祖先结点的栈
        bool findAncestors(BinTreeNode<T> *subTree, const T &item, Stack<BinTreeNode<T> *> &s) const;
        //将以current为根结点的所有叶子结点从左往右连接成一个链表，返回首地址
        void leafLinkedList(BinTreeNode<T> *current, LinkNode<T> *&last);
        void CreateBinTreeByList(istream &in) {CreateBinTreeByList(in, root);}                  //根据输入广义表建树
        void PringBinTreeByList(BinTreeNode<T> *subTree) const;                                 //输出该subTree为根的树的广义表
        LinearBinTreeNode<T> *toLinearBinaryTree(BinTreeNode<T> *subTree) const;                //将二叉链式结构转换成顺序存储结构，函数返回数组首地址
};

//私有函数：若指针subTree不为空，则删除根为subTree的子树
template <class T>
void BinaryTree<T>::destroy(BinTreeNode<T> *&subTree)
{
    if (subTree != NULL)
    {
        destroy(subTree->leftChild);                                //递归删除subTree的左子树
        destroy(subTree->rightChild);                               //递归删除subTree的右子树
        delete subTree;                                            //递归删除subTree
    }
}

//私有函数：从结点subTree开始，搜索结点current的父结点。若找到，则返回父结点地址，否则返回NULL
template <class T>
BinTreeNode<T> *BinaryTree<T>::Parent(BinTreeNode<T> *subTree, BinTreeNode<T> *current) const
{
    if (subTree == NULL) return NULL;
    if (subTree->leftChild == current || subTree->rightChild == current)
        return subTree;    //找到，返回父结点subTree
    BinTreeNode<T> *p;
    if (p = Parent((subTree->leftChild, current)) != NULL) return p;        //递归在左子树中搜索
    else return Parent((subTree->rightChild, current));                      //递归在右子树中搜索
}

//私有函数：搜索并输出根为subTree的二叉树
template <class T>
void BinaryTree<T>::traverse(BinTreeNode<T> *subTree, ostream &out) const
{
    if (subTree != NULL)
    {
        out << subTree->data << " ";                //输出subTree的值
        traverse(subTree->leftChild, out);          //递归搜索并输出subTree的左子树
        traverse(subTree->rightChild, out);          //递归搜索并输出subTree的右子树
    }
}

//私有函数，返回subTree为根的树的高度
template <class T>
int BinaryTree<T>::Height(BinTreeNode<T> *subTree) const
{
    if (subTree == NULL) return 0;
    int i = Height(subTree->leftChild), j = Height(subTree->rightChild);
    return (i < j) ? j + 1 : i + 1;
}

//私有函数，返回subTree为根树的结点数
template <class T>
int BinaryTree<T>::Size(BinTreeNode<T> *subTree) const
{
    if (subTree == NULL) return 0;
    return 1 + Size(subTree->leftChild) + Size(subTree->rightChild);
}

//重载操作：输入并建立一棵二叉树Tree,in为输入流对象
template <class T>
istream &operator >> (istream &in, BinaryTree<T> &Tree)
{Tree.CreateBinTree(in, Tree.root); return in;}

//重载操作：输出一棵二叉树Tree，out是输出流对象
template <class T>
ostream &operator << (ostream &out, BinaryTree<T> &Tree)
{
    out << "二叉树的前序遍历\n";
    Tree.traverse(Tree.root, out);              //从根开始输出
    out << endl; return out;
}

//私有函数：以前序遍历递归方式建立二叉树
template <class T>
void BinaryTree<T>::CreateBinTree(istream &in, BinTreeNode<T> *&subTree)
{
    T value; in >> value;
    if (value != RefValue)
    {
        subTree = new BinTreeNode<T>(value);              //建立根结点
        if (subTree == NULL) {cerr << "存储分配错误！" << endl; exit(1);}
        CreateBinTree(in, subTree->leftChild);            //递归建立左子树
        CreateBinTree(in, subTree->rightChild);           //递归建立右子树
    }
    else subTree = NULL;                                  //封闭指向空子树的指针
}

//输入广义表表示建立二叉树
template <class T>
void BinaryTree<T>::CreateBinTreeByList(istream &in, BinTreeNode<T> *&subTree)
{
    SeqStack<BinTreeNode<T> * > s;
    subTree = NULL;
    BinTreeNode<T> *p = NULL, *t = NULL; int k = 0;           //k为处理左、右子树标记
    T ch; in >> ch;                                           //从in顺序读入一个字符
    while (ch != RefValue)
    {
        switch (ch)
        {
            case '(': s.push(p); k = 1; break;          //进入子树
            case ')': s.pop(t); break;                  //退出子树
            case ',': k = 2; break;
        default: p = new BinTreeNode<T>(ch);
            if (p == NULL) {cerr << "存储分配错误！" << endl; exit(1);}
            if (subTree == NULL) subTree = p;
            else if (k == 1) {s.getTop(t); t->leftChild = p;}               //链入*t的左子女
            else {s.getTop(t); t->rightChild = p;}               //链入*t的右子女
        }
        in >> ch;
    }
}

//私有函数：这个函数返回一个指针，它给出一个以orignode为根的二叉树的副本
template <class T>
BinTreeNode<T> *BinaryTree<T>::copy(BinTreeNode<T> *orignode) const
{
    if (orignode == NULL) return NULL;                          //根为空，返回空指针
    BinTreeNode<T> *temp = new BinTreeNode<T>;                  //创建空结点
    if (temp == NULL) {cerr << "存储分配错误！" << endl; exit(1);}
    temp->data = orignode->data;                                //传送数据
    temp->leftChild = copy(orignode->leftChild);                //复制左子女
    temp->rightChild = copy(orignode->rightChild);              //复制右子女
    return temp;
}

//判断两棵二叉树相等
template <class T>
int operator == (const BinaryTree<T> &s, const BinaryTree<T> &t)
{return (equal(s.root, t.root)) ? true : false;}

//如果a和b的子树不等同，则函数返回false，否则返回true
template <class T>
bool equal(const BinTreeNode<T> *a, const BinTreeNode<T> *b)
{
    if (a == NULL && b == NULL) return true;                    //两者都为空
    if (a != NULL && b != NULL && a->data == b->data            //两者跟结点数据相等
        && equal(a->leftChild, b->leftChild)                    //且左子树相同
        && equal(a->rightChild, b->rightChild))                 //且右子树相同
    return true;
    else return false;
}

//查找x，并返回该结点的地址
template <class T>
BinTreeNode<T> *BinaryTree<T>::find(BinTreeNode<T> *subTree, const T &x) const
{
    if (subTree == NULL) return NULL;                       //到达空结点，返回NULL
    if (subTree->data == x) return subTree;                 //找到x，返回该结点地址
    BinTreeNode<T> *temp = find(subTree->leftChild, x);
    return (temp != NULL) ? temp : find(subTree->rightChild);
}


//递归前序遍历
template <class T>
void BinaryTree<T>::preOrder(BinTreeNode<T> *subTree, void (*visit)(BinTreeNode<T> *current))
{
    if (subTree != NULL)
    {
        visit(subTree);
        preOrder(subTree->leftChild, visit);
        preOrder(subTree->rightChild, visit);
    }
}

//递归中序遍历
template <class T>
void BinaryTree<T>::inOrder(BinTreeNode<T> *subTree, void (*visit)(BinTreeNode<T> *current))
{
    if (subTree != NULL)
    {
        preOrder(subTree->leftChild, visit);
        visit(subTree);
        preOrder(subTree->rightChild, visit);
    }
}

//递归后序遍历
template <class T>
void BinaryTree<T>::postOrder(BinTreeNode<T> *subTree, void (*visit)(BinTreeNode<T> *current))
{
    if (subTree != NULL)
    {
        preOrder(subTree->leftChild, visit);
        preOrder(subTree->rightChild, visit);
        visit(subTree);
    }
}

//按广义表的形式将二叉树输出
template <class T>
void BinaryTree<T>::PringBinTreeByList(BinTreeNode<T> *subTree) const
{
    if (subTree != NULL)                                    //树为空结束递归
    {
        cout << subTree->data;                              //输出根结点的值
        if (subTree->leftChild != NULL || subTree->rightChild != NULL)
        {
            cout << '(';                                    //输出左括号
            PringBinTreeByList(subTree->leftChild);         //递归输出左子树
            if (subTree->rightChild != NULL)                //右子树不为空
            {
                cout << ',';
                PringBinTreeByList(subTree->rightChild);    //递归输出右子树
            }
            cout << ')';                                    //输出右括号
        }
    }
}

//利用队列实现层次序遍历
template <class T>
void BinaryTree<T>::leverOrder(void (*visit)(BinTreeNode<T> *current))
{
    LinkedQueue<BinTreeNode<T> * > Q;
    BinTreeNode<T> *current = root;
    Q.EnQueue(current);
    while (!Q.isEmpty())                                //队列不为空
    {
        Q.DeQueue(current); visit(current);             //退出一个结点，访问
        if (current->leftChild != NULL) Q.EnQueue(current->leftChild);        //左子女进队
        if (current->rightChild != NULL) Q.EnQueue(current->rightChild);      //右子女进队
    }
}

//对一棵树的所有叶子结点，从左往右连接成一条单链表
//current为树的根结点，last为链表表头首地址
template <class T>
void BinaryTree<T>::leafLinkedList(BinTreeNode<T> *current, LinkNode<T> *&last)
{
    if (current == NULL) return;
    if (current->leftChild == NULL && current->rightChild == NULL)                  //均无左右子女为叶子结点
    {
        LinkNode<T> *newNode = new LinkNode<T>(current->data);
        if (newNode == NULL) {cerr << "存储分配错误！" << endl; exit(1);}
        last->link = newNode;
        last = last->link;
    }
    else
    {
        leafLinkedList(current->leftChild, last);                              //递归对左子树叶子结点建链
        leafLinkedList(current->rightChild, last);                             //递归对右子树叶子结点建链
    }
}

////根据值找到该结点，并通过引用返回存储所有祖先结点的栈
template<class T>
bool BinaryTree<T>::findAncestors(BinTreeNode<T> *current, const T &item, Stack<BinTreeNode<T> *> &s) const
{
    if (current == NULL) return false;                      //到达空结点，返回false
    //所寻找的值在当前结点的左子树或右子树，该结点进栈
    if (findAncestors(current->leftChild, item, s) || findAncestors(current->rightChild, item, s))
    {s.push(current); return true;}                         //将该结点进栈
    if (current->data == item) return true;                 //找到储存值所在的结点
    return false;
}

//将二叉链式结构转换成顺序存储结构，函数返回数组首地址;
//index标记当前数组第几个元素
template <class T>
LinearBinTreeNode<T> *BinaryTree<T>::toLinearBinaryTree(BinTreeNode<T> *current) const
{
    if (current == NULL) return NULL;                                               //根结点为空，返回空
    LinkedQueue<BinTreeNode<T> *> traverse;                                         //层次遍历每个结点队列
    LinkedQueue<int> parent;                                                        //存放父结点的队列
    int count = 0, currentindex = 0, temp = 0, size = Size();                       //count统计结点数，currentindex为当前处理的结点
    LinearBinTreeNode<T> *arr = new LinearBinTreeNode<T>[size]();
    traverse.EnQueue(current);                                                      //从根结点开始队列处理
    parent.EnQueue(-1);                                                             //根结点无父节点，-1进队
    while (!traverse.isEmpty())                                                     //队列不为空
    {
        traverse.DeQueue(current); parent.DeQueue(temp);                            //退出一个结点，
        arr[currentindex].data = current->data; arr[currentindex].parent = temp;
        if (current->leftChild != NULL) 
        {
            traverse.EnQueue(current->leftChild);                                   //左子女进队
            arr[currentindex].leftChild = ++count;                                  //父节点的左子女索引
            parent.EnQueue(currentindex);                                           //该结点成为其子女的父节点
        }
        if (current->rightChild != NULL)
        {
            traverse.EnQueue(current->rightChild);                                  //右子女进队
            arr[currentindex].rightChild = ++count;                                 //父节点的右子女索引
            parent.EnQueue(currentindex);                                           //该结点成为其子女的父节点
        }
        currentindex++;
    }
    return arr;
}

//创建一棵具有n个结点的完全二叉树的顺序储存结构，返回创建后的数组
template <class T>
LinearBinTreeNode<T> * createCompleteLinearBinaryTree(int n)
{

    LinearBinTreeNode<T> *arr = new LinearBinTreeNode<T>[n];
    cout << "请分别输入每个结点的数据：";
    for (int i = 0; i < n; i++)
    {
        cin >> arr[i].data;
        arr[i].parent = floor((i - 1) / 2.0);
        if (2 * i + 1 < n) arr[i].leftChild = 2 * i + 1;           //当前结点拥有左子女
        if (2 * i + 2 < n) arr[i].rightChild = 2 * i + 2;           //当前结点拥有左子女
    }
    return arr;
}


//对二叉树的顺序存储结构，使用非递归方式实现中序遍历
template <class T>
void preOrder(LinearBinTreeNode<T> *arr, void (*visit)(LinearBinTreeNode<T> &current) )
{
    SeqStack<int> s; int p = 0;                              //p为遍历指针，从根结点序号开始
    do
    {
        while (p > -1)                                       //指针未进入到最左下的结点，不空
        {
            s.push(p);                                       //该子树沿途结点进栈
            p = arr[p].leftChild;                            //遍历指针进到到左子女结点
        }
        if (!s.isEmpty())
        {
            s.pop(p); visit(arr[p]);                         //退出一个结点，访问根结点
            p = arr[p].rightChild;                           //进入右子女结点
        }
    } while (p > -1 || !s.isEmpty());                        //p > -1不能去掉，表示仍有结点未访问
}

#endif //BINARYTREE_H